<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        body{
            min-height: 100vh;
        }
        textarea{
            font-family: 'CMU Serif';
            font-size: 23px;
            width: 50%;
            height: 300px;
        }
    </style>
</head>
<body>
    <textarea name="writeas" id="writehere" cols="30" rows="10">
        Lorem ipsum dolor sit amet consectetur adipisicing elit. Inventore possimus quisquam doloremque quibusdam odit sapiente voluptates sint vel nam molestias aliquam fugiat dolor, eveniet ad deleniti ipsam dicta. Placeat, totam!
    </textarea>
    <script>
        var allowedFileTypes = ["image/png", "image/jpeg"];

        // using getElementsByTagName instead of querySelector for
        // more backward compatibility (and probably performance)
        var dropbox = document.getElementsByTagName("body")[0];
        dropbox.addEventListener("drop", drop, true);
        dropbox.addEventListener("dragover", function(e){
            if (e.target.tagName != "TEXTAREA"){
                e.preventDefault();
            } else {
                // save the old textarea text so that we can ignore existing 'file://' uris
                oldtext = textarea.value;
                // console.log(e);
                // e.preventDefault();
            }
        }, true)

        var textarea = document.getElementsByTagName("textarea")[0];
        var oldtext = textarea.value;
        var progressCharacter = "âˆŽ";

        function drop(e) {
            var files = e.dataTransfer.files;
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                // from https://stackoverflow.com/a/1818400/400257
                description = file.name.substr(0, file.name.lastIndexOf('.')) || file.name;
                file.identifier = description+"_"+Math.random().toString(36).substring(2, 15);
                file.progress = 0;
                markdown = " [" + file.identifier + "](00%) ";
                // if we drop on a textarea, on firefox, we can get the position of the drop
                // by searching for the 'file://' uri that it appends to the textarea by default
                if (e.target.tagName != "TEXTAREA"){
                    insertTextAtCursor(markdown, textarea);
                    e.preventDefault(); 
                } else {
                    // at this point the text in the textarea is still the original one

                    // This is dirty, I know but I can't figure out a better way
                    setTimeout( function(){insertTextAtDropPoint(markdown, textarea, file.name)},10);
                }
                handleFile(file);
            }
        }

        function insertTextAtCursor(text, textarea){
            if (textarea.nodeName == "TEXTAREA") {
                // save cursor position so that we can set it back after the operation on value
                var startingPosition = textarea.selectionStart;
                var textBeforeCursor = textarea.value.substring(0, textarea.selectionStart);
                var textAfterCursor = textarea.value.substring(textarea.selectionEnd, textarea.value.length);
                textarea.value = textBeforeCursor + text + textAfterCursor;
                // set the cursor to its original position
                textarea.selectionStart = textarea.selectionEnd = startingPosition + text.length;
            } else throw "Element is not a textarea"
        }

        function insertTextAtDropPoint(text, textarea, filename){
            if (textarea.nodeName == "TEXTAREA") {
                // save cursor position so that we can set it back after the operation on value
                var startingPosition = textarea.selectionStart;
                var rxp = new RegExp('file://.*?/'+filename);
                console.log(rxp);
                textarea.value = replaceNewPatternInString(rxp, oldtext, textarea.value, text);
                // set the cursor to its original position
                textarea.selectionStart = textarea.selectionEnd = startingPosition + text.length;
            } else throw "Element is not a textarea"
        }

        function replaceNewPatternInString(pattern, oldstring, newstring, replacement){
            var index = 0;
            do {
                // find first occurence of pattern
                var match = newstring.substr(index, newstring.length).match(pattern);
                index += match.index;
                // take the part of the string from the beginning until the end of the pattern
                // and check if you can find it in the old string
                // if you can go to the next occurence of the pattern until you find one
                // that doesn't exist in the old string.
                index += match[0].length;
            } while (oldstring.indexOf(newstring.substr(0, index)) != -1);
            return newstring.substr(0,index-match[0].length) + replacement + newstring.substr(index,newstring.length);
        }

        function handleFile(file){
            var ok = false;
            for (var i in allowedFileTypes){
                if (file.type.match(allowedFileTypes[i])) {ok=true; break;}
            }
            if (!ok) throw "disallowed file type";

            // var reader = new FileReader();
            // reader.readAsDataURL(file);
            var xhr = new XMLHttpRequest();
            // progressMgmt(xhr,file,img);
            xhr.open("POST", "upload.php");
            xhr.setRequestHeader("Cache-Control", "no-cache");
            xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
            xhr.setRequestHeader("X-File-Name", file.name);
            xhr.setRequestHeader("X-File-Size", file.size);

            xhr.upload.onprogress = function(e) {
                if (e.lengthComputable) {
                    var startingPosition = textarea.selectionStart;
                    var loaded = Math.ceil((e.loaded / e.total)*100);
                    if (file.progress + 5 < loaded){
                        file.progress = loaded;
                        textarea.value = textarea.value.replace(getMarkdownRegex(file.identifier), "["+ file.identifier +"]("+padLeft(loaded,2)+"%)");
                        textarea.selectionStart = textarea.selectionEnd = startingPosition;
                    }
                }
            }

            var formData = new FormData();
            formData.append('file', file);
            xhr.send(formData);
            xhr.onreadystatechange = function(){
                if(xhr.readyState == 4){
                    processResponse(xhr.responseText, file.identifier);
                }
            }
        }

        function processResponse(responseText, identifier){
            var response = JSON.parse(responseText);
            description = response.name.substr(0, response.name.lastIndexOf('.')) || response.name;
            textarea.value = textarea.value.replace(getMarkdownRegex(identifier), "["+ description +"]("+response.url+")");
        }

        function getMarkdownRegex(identifier){
            return new RegExp('\\[' + identifier + '\\]\\(.*?\\)'); 
        }

        function padLeft(number, padTo, str){
            return Array(padTo-String(number).length+1).join(str||'0')+number;
        }
    </script>
</body>
</html>